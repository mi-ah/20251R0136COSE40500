# -*- coding: utf-8 -*-
"""Challenge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iNUNIXbo4fTJOhlAvnl5kRdMdpyczCfp
"""

import itertools
#챗gpt로 itertools에 대해 배우고 활요하기로 했음

City = list()
city_names = input().split()
City.extend(city_names)

# 데이터 입력
N = len(City)
city_dict = {i: city_names[i] for i in range(N)}

G = list()

for i in range(0, N):
  row = input()
  row = row.split()
  for j in range(0, N):
    row[j] = int(row[j])
  G.append(row)

# dist[u][v] : u -> v의 최단거리. 경로가 없으면 INF(infinite)
INF = 9999999999999999
dist = [[INF]*N for i in range(N)]

for u in range(N):
  dist[u][u] = 0 # 자기 자신과의 거리는 0
  for v in range(N):
    if G[u][v] != 0:
      dist[u][v] = G[u][v] # 간선 1개

for k in range(N):
  for u in range(N):
    for v in range(N):
      # u->k->v 거리가 현재 u->v보다 짧으면 업데이트
      if dist[u][k] + dist[k][v] < dist[u][v]:
        dist[u][v] = dist[u][k] + dist[k][v]


# 대피소
# 각 자치구에 대피소를 지었을 때 커버할 수 있는 자치구 집합들
cover = [set() for _ in range(N)]
for u in range(N):
  for v in range(N):
    # u->v 경로가 있으면 v는 u를 커버 가능
    if dist[u][v] != INF:
      cover[v].add(u)

# 대피소의 개수 후보 지정(1부터 N까지)
answer = None # 초기값
for count in range(1, N+1):
  # 0,1,...,n-1 에서 count개의 집합
  for comb in itertools.combinations(range(N), count):
    total_cover = set()
    for v in comb:
      total_cover = total_cover | cover[v] # 합집합
    # 현재 comb의 cover들의 합집합 원소의 개수가 N이면 -> 모두 커버했다는 뜻
    if len(total_cover) == N:
      # 정답을 저장하고 break
      answer = comb
      break
  # 정답이 찾아졌으면 break
  if answer is not None:
    break

refuge_names = []
if answer is not None:
    refuge_names = [city_dict[refuge_index] for refuge_index in answer]

print(f'{", ".join(refuge_names)}')

# 여기서부터 슈하다 학생과 같이 의논한 결과
# 소방서
# 거리 조건(역주행 가능)을 바꿔서 플로이드 재실행
INF = 9999999999999999
dist = [[INF]*N for i in range(N)]

for u in range(N):
  dist[u][u] = 0 # 자기 자신과의 거리는 0
  for v in range(N):
    if G[u][v] != 0:
      dist[u][v] = min(dist[u][v], G[u][v]//2) # 속도가 2배므로 실질 거리가 //2가 되는 효과
      dist[v][u] = min(dist[v][u], 2*G[u][v]) # 속도가 절반이므로 실질 거리가 2배가 되는 효과

for k in range(N):
  for u in range(N):
    for v in range(N):
      if dist[u][k] + dist[k][v] < dist[u][v]:
        dist[u][v] = dist[u][k] + dist[k][v]

# 기본 로직 : 두 후보를 정하고, 거리의 최대값이 최소가 되는 지점을 탐색
answer = (0,0)
min_dist = INF # 초기값 : infinite

for fireA in range(N):
  for fireB in range(N):
    if fireA == fireB:
      continue
    cur_dist = 0
    for v in range(N):
      # v를 기준으로, fireA, fireB와의 거리 중 최소값이 가장 가까운 소방서와의 거리가 됨
      # 이 값들의 최대값을 저장
      cur_dist = max(cur_dist, min(dist[fireA][v], dist[fireB][v]))
    # 이 값이 현재 답보다 좋으면 업데이트
    if cur_dist < min_dist:
        min_dist = cur_dist
        answer = (fireA, fireB)

#여기까지 슈하다 학생과 의논한 결과이다

fireA_name = city_dict[answer[0]]
fireB_name = city_dict[answer[1]]
print(f'{fireA_name}, {fireB_name}')

